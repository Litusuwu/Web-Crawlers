# TikTok Headless Browser Scraping — Evaluation Results

## Test Results

```
tests/test_proxy.py::test_proxy_config_loads ............... PASSED
tests/test_proxy.py::test_proxy_playwright_format .......... SKIPPED (no proxy configured)
tests/test_proxy.py::test_scraping_config_defaults ......... PASSED
tests/test_proxy.py::test_browser_config_defaults .......... PASSED
tests/test_detection.py::test_webdriver_is_hidden .......... PASSED
tests/test_detection.py::test_plugins_are_present .......... PASSED
tests/test_detection.py::test_languages_are_set ............ PASSED
tests/test_detection.py::test_chrome_object_exists ......... PASSED
tests/test_detection.py::test_viewport_dimensions .......... PASSED

8 passed, 1 skipped
```

Our stealth overrides successfully hide `navigator.webdriver`, fake the plugin array, set realistic languages, and ensure `window.chrome` exists. These are necessary but **not sufficient** for TikTok — read on.

---

## TikTok Anti-Bot System Analysis

TikTok runs one of the most aggressive anti-bot systems on the web. It is **not** a simple WAF or fingerprint check — it is a multi-layered defense built around a **custom JavaScript virtual machine**.

### The Custom VM

TikTok ships a proprietary bytecode VM in its client-side JavaScript. This is the core of the defense:

| Detail | Value |
|--------|-------|
| Custom opcodes | 178 |
| Encryption | AES-256-CBC + Leb128 (storage), Base64 + checksum (transport) |
| Memory model | Constant pools + heap + stack |
| Obfuscation techniques | 20+ (control flow flattening, variable encryption, etc.) |

This VM generates request signatures (`X-Bogus`, `_signature`, `msToken`) that **cannot be replicated** without executing TikTok's own JavaScript. This is why lightweight HTTP clients (`httpx`, `requests`) alone cannot scrape TikTok — they can't produce valid signatures.

### Detection Layers

TikTok stacks five detection layers. Bypassing one is not enough — they cross-validate signals across all of them:

| Layer | What It Checks | Can Puppeteer/Playwright Bypass? |
|-------|---------------|----------------------------------|
| **1. Transport** | TLS/JA3 fingerprint, HTTP/2 header order | Yes — real Chromium has correct TLS |
| **2. Browser Environment** | `navigator.webdriver`, canvas, WebGL, plugins, languages, `chrome.runtime` | Partially — stealth plugins help but TikTok checks deeper |
| **3. Behavioral** | Scroll speed, mouse curves, click timing, dwell time, tab focus | No — requires explicit simulation code |
| **4. Request Signatures** | Encrypted headers generated by the VM (`X-Bogus`, `_signature`) | Yes — if JS executes in a real browser |
| **5. Account/Session** | Login wall after ~3-5 loads, CAPTCHA, shadow-banning | No — requires account pools or CAPTCHA solving |

### What This Means in Practice

- After **3-5 unauthenticated page loads**, TikTok shows a login wall
- Even with stealth plugins, TikTok detects **behavioral patterns** (bots scroll too smoothly, click too consistently)
- Shadow-banning returns **empty or stale data** without any error, so you may not even know you're blocked
- TikTok updates its VM frequently, breaking any reverse-engineering efforts

---

## Puppeteer Feasibility

### puppeteer-extra-plugin-stealth: DETECTED by TikTok

The stealth plugin (v2.11.2) is **explicitly known to be detected** by TikTok in both headless and headful modes. The plugin developers themselves acknowledge this is a cat-and-mouse game.

Community workarounds that provide **partial, temporary** relief:
- Disable `chrome.runtime` evasion (it causes detection)
- Disable `navigator.languages` evasion (it causes detection)
- Manually delete `navigator.__proto__.webdriver`
- Use Firefox instead of Chromium (less fingerprinting)

### What Puppeteer CAN Do

| Capability | Works? | Notes |
|-----------|--------|-------|
| Load TikTok page initially | Yes | First 3-5 loads work |
| Execute TikTok's VM/JS | Yes | Signatures are generated correctly |
| Pass basic fingerprint checks | Partially | With stealth plugin + custom overrides |
| Infinite scroll | Briefly | Needs behavioral simulation |
| Sustained scraping (100+ pages) | **No** | Blocked by behavioral + session detection |
| Avoid login wall | **No** | Triggers after few unauthenticated loads |
| Run without residential proxy | **No** | Datacenter IPs are instantly blocked |

### What Puppeteer CANNOT Do (Even With Stealth)

1. **Bypass behavioral analysis** — TikTok tracks mouse movement curves, scroll velocity variance, click timing jitter, and dwell time. Puppeteer actions are too mechanical without extensive simulation.
2. **Maintain long sessions** — Login walls and CAPTCHAs cut off unauthenticated access after a handful of loads.
3. **Scale** — Each additional request increases detection probability. Parallelism makes it worse, not better.
4. **Stay stable** — TikTok updates its anti-bot frequently. Any working approach breaks within weeks.

### Verdict

| Approach | Feasibility | Reliability | Maintenance |
|----------|-------------|-------------|-------------|
| Puppeteer + stealth (no proxy) | Not viable | 0% | N/A |
| Puppeteer + stealth + residential proxy | Low | ~20-30% | Very high (breaks often) |
| Puppeteer + stealth + proxy + behavioral sim | Medium | ~40-60% | Very high |
| Third-party service (Apify, ScrapFly) | High | ~95%+ | Low (they maintain it) |
| TikTok Research API (if approved) | High | 100% | None |

**Bottom line:** Puppeteer/Playwright *can* load TikTok pages and extract initial data, but it **cannot sustain** scraping at any meaningful scale without residential proxies, behavioral simulation, CAPTCHA solving, and constant maintenance. For production use, a third-party scraping service or the Research API are the only reliable paths.

---

## Quick Start

```bash
cd TikTok/
uv sync
uv run playwright install chromium
cp .env.example .env   # configure proxy credentials
uv run pytest tests/ -v
```

## Project Structure

```
TikTok/
├── pyproject.toml                          # uv deps (playwright, nodriver, httpx, etc.)
├── .env.example                            # proxy + browser config template
├── src/tiktok_scraper/
│   ├── config.py                           # pydantic config from .env
│   ├── stealth_config.py                   # chrome args + JS overrides
│   ├── scrapers/
│   │   ├── playwright_scraper.py           # playwright + stealth approach
│   │   ├── nodriver_scraper.py             # CDP-based (no webdriver footprint)
│   │   └── hydration_scraper.py            # httpx + JSON hydration (lightest)
│   └── utils/
│       ├── behavioral.py                   # human-like scroll/mouse simulation
│       ├── proxy.py                        # proxy health checking
│       └── fingerprint.py                  # coherent browser fingerprint profiles
├── tests/                                  # 8 passed, 1 skipped
├── scripts/
│   ├── check_detection.py                  # baseline: bot-detection test sites
│   ├── evaluate_stealth.py                 # compare approaches against TikTok
│   └── benchmark_lambda.py                 # Lambda cost/feasibility analysis
└── README.md
```

Full technical report: [`TikTokHeadlessScraping.md`](../TikTokHeadlessScraping.md)


. World Models (2018)

Resumen: Introduce un agente compuesto por un modelo de visión (VAE) que comprime cuadros de imagen en vectores latentes, y un modelo de memoria (RNN) que predice estados futuros basándose en acciones previas.

Relación con el Método: Es el fundamento teórico que demuestra que un agente puede entrenarse completamente dentro de su propio "sueño" (simulación interna) y transferir ese aprendizaje al entorno real con éxito.

2. PlaNet: Deep Planning Network (2019)

Resumen: Propone el Recurrent State-Space Model (RSSM), que combina componentes deterministas y estocásticos para capturar la incertidumbre en predicciones de múltiples pasos.

Relación con el Problema/Método: Establece el uso de planificación online (MPC) en el espacio latente sin necesidad de reconstruir imágenes, lo que aumenta drásticamente la eficiencia de datos frente a métodos libres de modelo.

3. DreamerV1 (2020)

Resumen: Evoluciona PlaNet al introducir un actor y un crítico que se entrenan puramente mediante imaginación latente, propagando gradientes analíticos a través de las trayectorias del modelo.

Relación con el Problema/Método: Permite resolver tareas de largo horizonte (como locomoción compleja) de manera más eficiente que la planificación online pura, sentando las bases del aprendizaje de políticas en espacios latentes.

4. DreamerV2 (2021)

Resumen: Introduce el uso de variables latentes categóricas (discretas) en lugar de gaussianas y una técnica de balanceo de la divergencia KL para regularizar el aprendizaje.

Relación con el Problema/Método: Fue el primer algoritmo basado en modelos de mundo en alcanzar un rendimiento de nivel humano en el benchmark de Atari, demostrando que la discretización latente es clave para la robustez en entornos visuales complejos.

5. DreamerV3 (2023) - Artículo por Replicar

Resumen: Algoritmo generalista que utiliza técnicas de robustez como la transformación symlog y la normalización de retornos por percentiles para operar con hiperparámetros fijos en diversos dominios.

Relación con el Problema/Método: Es el primer algoritmo que logra recolectar diamantes en Minecraft desde cero sin datos humanos, estableciendo el estado del arte en generalidad para agentes inteligentes.